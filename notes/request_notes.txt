/***************** Requests *******************/

/* Fill map headers */

// Utiliser getline en transformant la string en ofstream pour lire ligne par ligne la string. 
// Ligne contenu dans une string
// Stocker dans des variables ce qu il y a avant et apres les ":"
// Mettre ces variables dans une paire dans la map headers

/*void fillHeaders(std::string req) {
 	 for(unsigned int i = 0; i < req.size(); i++) {
  	if (req[i] == ':') {
 	 	std::string key = ; // partie de la string avant les ":" couper la string 
  		std::string value; // mettre de i + 1 a la fin de la ligne
  		this->headers = std::make_pair(key, value);
  	}
  }
}*/

/* Fill type of the request */

// Boucle jusqu'au premier espace car headers commencent par :
// GET /TRUC
// Checker que ce soit une requete Get, post ou delete

bool fillType(std::string req) {
		std::string tmp;
		for (unsigned int i = 0; i != ' ' && req.size() > 0; i++)
				tmp[i] = req[i];
		if ( tmp != type[0] && tmp != type[1] && tmp != type[2]) {
				std::cout << "Request type not found" << std::endl;
				return false;
				else
						std::cout << "Youpi we have the type of the request now! ðŸ¥³" << std::endl;
		}
		return true;
}


		Request(std::string req)/* : headers(NULL, NULL) */{
			// Fill map headers :
			std::stringstream tmp(req);
			std::string line;
			//std::string h_key;
			//std::string h_val;
			while (!tmp.eof()) {
				std::getline(tmp, line); // recupere la ligne
					/*
				//->
				unsigned int i = 0;
				while (line[i] != ':')
					i++; // est ce utile de faire dans un tmp, il doit etre possible de des que je sort de la boucle mettre ce que j ai dans line jusqu a la position de i dans key et le reste dans value
				h_key.assign(line, 0, i);
				h_val.assign(line, i, line.size() - i);
				//this->headers = std::make_pair(h_key, h_val);
				this->headers.insert(std::pair<std::string, std::string>(h_key, h_val));
				this->headers.insert(std::pair<std::string, std::string>(h_key, h_val));
						
				// ->
				//this->headers = std::make_pair(line.substr(0, i), line.substr(i, line.size() - i)); //peut etre mettre i - 1 si i = ":"
				this->headers.insert(std::pair<std::string, std::string>(line.substr(0, i), line.substr(i, line.size() - i))); //peut etre mettre i - 1 si i = ":"
						*/
				// ->
				size_t pos = line.find(":");
				if (pos != std::string::npos)
					this->headers.insert(std::pair<std::string, std::string>(line.substr(0, pos), line.substr(pos, line.size() - pos))); //peut etre mettre i - 1 si i = ":"
				else
					this->code = 400;
				//this->headers.insert(std::pair<std::string, std::string>(line.substr(0, pos), line.substr(pos)));
			}
			for (std::map<std::string,std::string>::iterator it = this->headers.begin(); it != this->headers.end(); it++)
				std::cout << it->first << " -> " << it->second << std::endl;
		}

--- NOTES ---

enum class = c++11 donc ne peut etre utilisee

-> voir comment remplacer string type par un enum âœ… 
-> stringstream est un istream âœ…
-> Mettre fonctions dans le .cpp âœ…
-> remplacer print error basic par l'affichage de la page d'erreur et le code erreur qui va avec ? âœ…
-> variable private code = mise a jour du code erreur âœ…

Client Error 4xx ............................................65
10.4.1    400 Bad Request .........................................65
10.4.2    401 Unauthorized ........................................66
10.4.3    402 Payment Required ....................................66
10.4.4    403 Forbidden ...........................................66
10.4.5    404 Not Found ...........................................66
10.4.6    405 Method Not Allowed ..................................66
10.4.7    406 Not Acceptable ......................................67
10.4.8    407 Proxy Authentication Required .......................67
10.4.9    408 Request Timeout .....................................67
10.4.10   409 Conflict ............................................67
10.4.11   410 Gone ................................................68
10.4.12   411 Length Required .....................................68
10.4.13   412 Precondition Failed .................................68
10.4.14   413 Request Entity Too Large ............................69
10.4.15   414 Request-URI Too Long ................................69
10.4.16   415 Unsupported Media Type ..............................69
10.4.17   416 Requested Range Not Satisfiable .....................69
10.4.18   417 Expectation Failed ..................................70

-> Recuperer headers âœ… OK
-> Recuperer type header âœ… OK

-> Pour la reponse, je dois renvoyer le header et wael renvoie le body qui sont concatener en suite
pour former la reponse.
-> Pour la requete : 
	- Parser et comprendre ce que le client demande
	- Regarder a quoi ressemble differentes requetes
	- 5 bodys differents minimum : post, delete, download, Get : ex: recuperer un html, CGI ...


->Doit pouvoir heberger n'importe quel site donc faire attention aux requetes possibles.


Type de formulaire http : (pour les requetes post et le content-type)

<form action="/" method="post" enctype="multipart/form-data">
	<input type="text" name="description" value="du texte">
    <input type="file" name="monFichier">
	<button type="submit">Envoyer</button>
</form>

Exemple de requete POST simple avec CGI :

POST /cgi-bin/program.pl HTTP/1.0
Accept: www/source
Accept: text/html
Accept: text/plain
User-Agent: Lynx/2.4 libwww/2.14
Content-type: application/x-www-form-urlencoded
Content-length: 35
user=Larry%20Bird&age=35&pass=testing


